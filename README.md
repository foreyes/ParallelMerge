# ParallelMerge

## 概述
该问题从本质上是一个 K 路归并的问题，在此对 K 路归并问题进行展开讨论。

#### 单线程 K 路归并
朴素的单线程 K 路归并如果希望性能尽可能好，必须要尽快地找到 K 路里面最小的元素，且能进行实时更新。

简单的有 O(K) 的直接遍历，也有基于优先队列的 O(logK) 实现，以及在 O(logK) 的基础上有基于败者树（LoserTree）的常数优化实现。

时间复杂度分析：
- 朴素的遍历归并，总时间复杂度 O(kn);
- 基于优先队列/败者树归并，总时间复杂度 O(logkn)，k 较小时由于常数较大，效果并不如朴素做法;
- 每次将 m 路进行归并，直到完成总的归并，总时间复杂度 O(m * log_mk * n)，化简后为 O(m/logm * logk * n)，当 m = 3（接近自然对数 e） 时理论上最小，但仍不如基于优先队列归并；
- 每次将 m 路基于优先队列/败者树进行归并，直到完成总的归并，总时间复杂度 O(logm * log_mk * n)，化简之后同样是 O(logkn)，但是可以更方便地进行多线程；

#### 多线程 K 路归并
进一步，如果考虑通过多线程来提高整个归并的效率，不可避免地要对任务进行切分和整合。

假设我们有 4 个线程，比较容易想到两种切分方式：
- 水平切分：每个线程先将 K/4 路进行归并，再将最后的结果整合起来；
- 垂直切分：将值域切分成 4 个不相交的区间，使得每一块的数据量尽量相等，每个线程负责一个值域，然后将结果按顺序拼接起来。

值得注意的是，垂直切分之后是可以继续进行水平切分的，反之亦然。

### 细节思考
一般而言，对大量数据进行处理得到有序的结果集之后，该结果集会作为整个系统的输出，或者作为下一个模块的输入，并不会直接输出到 stdout。

整个算法的瓶颈点很大程度在于最后一轮的归并，以及输出到 stdout。如果我们深入分析系统的实际目的，可以设计更加有效的算法，或者指导我们做一些取舍：
- 假设我们希望尽量快地处理完所有数据，并将结果保存在某个缓冲区。此时采取值域切分的方式，按照不同的值域进行任务拆分，最后的结果可以缓存在不同的缓冲区中，不需要再进行拼接，或许能直接通过 TCP 将该缓冲区的内容直接发送到 client 端以供后续使用；【该做法能使得并行效率极高】
- 假设我们希望每两条数据的返回间隔控制在某个阈值内，在此基础上希望整体时间最短。这种情况下，水平切分时完成了所有子的归并之后再进行大的归并的做法是不可取的，需要通过小 batch 的方式来实现。
- 假设我们希望能够处理 K 路无限长的时间序列信息。此时水平切分依然有效，但需要通过 batch 的方式来实现；垂直切分需要不断地重新进行任务分配，使得每个线程处理完当前值域之后继续处理接下来的值域。

多线程进行 K 路归并必然要产生额外的空间开销：如果是水平切分，可以在每个子的归并任务内维护一个小的 batch 缓存，当结果返回完之后就能清理掉；如果是垂直切分，则不得不产生大量中间结果，不过该中间结果也可以直接作为最终的输出缓冲区。

## 设计实现 & 简单测试
该项目实现了基于遍历查找、优先队列、败者树的单线程归并算法，同时实现了建立在其基础上的水平/垂直切分算法。

在 8 核个人 PC 上构造均匀分布的 1000 路数据，测试结果大致如下（仅归并完并遍历结果集，不含输出耗时）：

Naive                   -

优先队列                14s

败者树                  12s

优先队列 + 水平切分      6s

优先队列 + 垂直切分      4s

败者树 + 水平切分        4s

败者树 + 垂直切分        3s



【暂未加压测试/多次测试】

### 上层设计
为了使得整体代码逻辑简洁、易理解、易维护、易扩展，抽象了重要的概念：Channel

Channel 对应着一条数据流，主要实现 GetCurrent() 及 GetNext() 接口。

本项目中主要实现的 Channel：
- RawChannel：遍历内存数组获取顺序数据；
- MergeChannel：将多条 child Channel 的结果归并返回；
- LinkedChannel：将多条 Channel 的结果顺序连接起来（必须是有限长度 Channel）；
- SimpleMatChannel：将某个 Channel 的数据物化，即获取 Channel 内容并缓存起来【自带多线程功能】；
- BatchMatChannel：【暂未实现】通过给定的缓冲区将某个 Channel 逐渐物化，相比 SimpleMatChannel 降低首次返回的 Latency 以及空间开销；

同时对于 MergeChannel 实现了基于优先队列和败者树的 HeapMergeChannel 及 LoserMergeChannel。

添加新类型的 MergeChannel 仅需实现以下接口：
- BuildMerge() —— 在首次调用 GetNext() 前运行；
- GetMinCadidate() —— 返回当前最小元素对应的 child Channel 下标；
- OnChildPop() —— 取出最小元素后进行变更，类似优先队列的 pop 方法；

基于这些 Channel 能够很容易地实现不同的效果，也非常容易扩展：
- task4 将 1000...990000，这些值通过二分查找拿到 [start, end] 区间后直接生成对应的 RawChannel，多个 RawChannel 作为上层 MergeChannel 的 children;
- 基于优先队列/败者树进行归并：在上述基础上将 MergeChannel 指定为对应的子类（HeapMergeChannel，LoserMergeChannel）即可；
- 实现水平切分并行：将 K 路进行任务划分，每个任务对应生成一个 MergeChannel 再对其包一层 SimpleMatChannel 进行物化，再作为外层最终 MergeChannel 的 children 即可。由于 SimpleMatChannel 会自己开启新的线程来完成整个物化过程，很自然地就实现了多线程；
- 实现垂直切分并行：与水平切分类似，每个线程负责不同的值域，也是 Merge 之后通过 SimpleMatChannel 物化来实现并行，最终的结果通过 LinkedChannel 串起来；
